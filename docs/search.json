[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Develop an R package within an hour",
    "section": "",
    "text": "hanneoberman.github.io/pkg-dev\n—  Copyright Hanne Oberman, 2025 - CC BY-NC-SA 4.0  Materials developed by Amices team - Methodology & Statistics - Utrecht University",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#course-website",
    "href": "index.html#course-website",
    "title": "Develop an R package within an hour",
    "section": "",
    "text": "hanneoberman.github.io/pkg-dev",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Develop an R package within an hour",
    "section": "2 Contents",
    "text": "2 Contents\nThis tutorial assumes some prior knowledge and software installation.\n\nRequirements\n\nThe tutorial is broken into two parts:\n\nPart 1: Basics\nPart 2: Sharing\n\nThe 2023 version of this course (incl. recording) is available here.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "03_take-aways.html",
    "href": "03_take-aways.html",
    "title": "Take aways",
    "section": "",
    "text": "Now you know how to build and share an R package.\n\n\n\n\nPotential next steps include:\n\nCreating package documentation (e.g. vignettes)\nCreating a hex logo (e.g. with hexmake)\nCreating a package website (e.g. with pkgdown)\nChecking the FAIR-ness of your package (e.g. with howfairis, or BadgeApp)\nChecking the code coverage of your package (e.g. with Codecov)\nMaintaining the package (e.g. with GitHub issues)\nMaintaining contributions (e.g. with a code of conduct)\n\n\n\nThis workshop relies heavily on the R Packages book by Hadley Wickham and Jenny Bryan\n\n\n\n—  Copyright Hanne Oberman, 2025 - CC BY-NC-SA 4.0  Materials developed by Amices team - Methodology & Statistics - Utrecht University",
    "crumbs": [
      "Take aways"
    ]
  },
  {
    "objectID": "01_basics.html",
    "href": "01_basics.html",
    "title": "The basics",
    "section": "",
    "text": "This tutorial will teach you how to quickly create an R package. We start with a motivating example, then build an R package, and in the next part share it with the world.\n—  Copyright Hanne Oberman, 2025 - CC BY-NC-SA 4.0  Materials developed by Amices team - Methodology & Statistics - Utrecht University",
    "crumbs": [
      "Part 1: Basics"
    ]
  },
  {
    "objectID": "01_basics.html#motivating-example",
    "href": "01_basics.html#motivating-example",
    "title": "The basics",
    "section": "Motivating example",
    "text": "Motivating example\nThe problem\nIn order to demonstrate the creation of an R-package, we will identify some odd behavior in R:\n\nc(0.5, 1.5, 2.5, 3.5) |&gt; round()\n\n[1] 0 2 2 4\n\n\nWe can see that–by default–R rounds the number 1.5 to integer 2 and the number 2.5 also to integer 2. The reason for this behavior is the IEC 60559 standard where a 5 is expected to be rounded to the even digit.\nA solution\nIf we’d like to round up to the next integer, we can easily define the following function:\n\n# load necessary package for between() function\nlibrary(dplyr)\n# define function to load to the nearest integer\nround_to_integer &lt;- function(x){\n  # calculate difference between the value and the nearest integer below\n  diff &lt;- x - floor(x)\n  # for differences &lt; 0.5, return the nearest integer below\n  # for differences =&gt; 0.5, return the next nearest integer\n  ifelse(between(diff, 0.5, 1), ceiling(x), floor(x))\n}\n\nThis function rounds the vector c(0.5, 1.5, 2.5, 3.5) up to the next integer:\n\nc(0.5, 1.5, 2.5, 3.5) |&gt; round_to_integer()\n\n[1] 1 2 3 4\n\n\nAnd it rounds the vector c(0.49, 1.49, 2.49, 3.49) down to the previous integer:\n\nc(0.49, 1.49, 2.49, 3.49) |&gt; round_to_integer()\n\n[1] 0 1 2 3\n\n\nWe will put this function in an R package to be able to (re)use the function and share it with others.",
    "crumbs": [
      "Part 1: Basics"
    ]
  },
  {
    "objectID": "01_basics.html#creating-an-r-package",
    "href": "01_basics.html#creating-an-r-package",
    "title": "The basics",
    "section": "Creating an R package",
    "text": "Creating an R package\nThe goal of this workshop is to wrap the function round_to_integer() into a stand-alone R package, with package documentation and a referenceable Digital Object Identifier.\n\nSet-up the R session\nWe need the following packages to help us with building, testing and maintaining our package:\n\nlibrary(devtools)   # development tools\nlibrary(usethis)    # automated package and project setup\nlibrary(roxygen2)   # package documentation\nlibrary(testthat)   # unit testing\n\n\n\nPrepare the package structure\nWe need a location for our R package. The simplest approach to creating the skeleton for an R package is to use RStudio. The following gif outlines this procedure:\n\n\n\nAlternatively, use the usethis function create_package():\n\nusethis::create_package(path = \"../roundR\")\n\nAs you might notice, usethis is an “incredibly chatty program”1. It sets up a new project, with a folder structure and some required documents. We will go over the relevant folders and documents one-by-one.\n✔ Creating ../roundR/.\n✔ Setting active project to \"/path/on/your/machine/roundR\".\n✔ Creating R/.\n✔ Writing DESCRIPTION.\nPackage: roundR\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R (parsed):\n    * First Last &lt;first.last@example.com&gt; [aut, cre]\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to\n    pick a license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.3\n✔ Writing NAMESPACE.\n✔ Writing roundR.Rproj.\n✔ Adding \"^roundR\\\\.Rproj$\" to .Rbuildignore.\n✔ Adding \".Rproj.user\" to .gitignore.\n✔ Adding \"^\\\\.Rproj\\\\.user$\" to .Rbuildignore.\n✔ Opening /path/on/your/machine/roundR/ in a new session.\n✔ Setting active project to \"&lt;no active project&gt;\".\n\n\nExplore the package structure\nWe have now created the necessary structure for an R package. We can see this structure and the generated package files in the File Pane in RStudio.\n\n\n\nThe R subfolder contains all the R code for your package and the man folder contains all the corresponding function documentation (i.e., what is shown using the help() function in R).\nBy default, for a new R package generated by RStudio the file hello.R is generated inside the R directory.\n\n\n\nAs a matter of fact, the skeleton R package is already a fully functional R package. Try installing the package in the Build pane.\n\n\n\n\n\nEdit the description\nOpen the file DESCRIPTION from the file pane. The following window opens:\n\n\n\n\nNow, replace the contents of the DESCRIPTION file with\n\nPackage: roundR\nType: Package\nTitle: Round Numeric Values to the Nearest Integer\nVersion: 0.0.1\nAuthors@R: c(\n    person(\n      \"Hanne\", \"Oberman\",\n      email = \"h.i.oberman@uu.nl\",\n      role = c(\"aut\", \"cre\")\n    ),\n    person(\n      \"Gerko\", \"Vink\",\n      email = \"g.vink@uu.nl\",\n      role = c(\"aut\")\n    )\n  )\nDescription: By default, R rounds numeric values to even integers, following \n    the IEC 60559 standard. This package offers alternative functionality to \n    round to the closest integer.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\n\nThe DESCRIPTION file governs the information about the licence, authors, contributors, maintainers, etc. The argument lazyData: true indicates that data sets should be lazily loaded. This means that data will not occupy any memory unless it is needed. This is a good argument to have as default.\nWe also need to set a license. Running the following code from package usethis will write a permissive MIT license to the description file:\n\nusethis::use_mit_license()\n\nTo learn more about licencing, see the R Packages book.\nDon’t forget to save the updated DESCRIPTION file and change our names to your name.\n\n\nAdd the functional code\nNow it is time to extend the package with the functionality we promised in our updated DESCRIPTION. To do so, we can either manually add a new file in the R folder called round_to_integer.R, or do it programmatically:\n\nusethis::use_r(\"round_to_integer\")\n\nThe use_r() function from the usethis package is very convenient, because it creates the necessary file in the correct location and opens the file in the editor pane.\nWe can now copy our own rounding function to the round_to_integer.R file:\n\nround_to_integer &lt;- function(x){\n  # calculate difference between the value and the nearest integer below\n  diff &lt;- x - floor(x)\n  # for differences &lt; 0.5, return the nearest integer below\n  # for differences =&gt; 0.5, return the next nearest integer\n  ifelse(between(diff, 0.5, 1), ceiling(x), floor(x))\n}\n\n\n\n\nSet-up the package documentation\nNow that we have created the file for our functional code, and added the code itself, we should make the code file recognizable by R as a package function by adding function documentation.\nThe most flexible approach to creating and maintaining package documentation is to use “roxygen”, a special kind of code commenting style. The roxygen2 package is a convenient in-line documentation convention that generates a bunch of machine-readable files that are required for R packages, such as the NAMESPACE file and help files (one for each function in your package; collected as .Rd files in the man folder).\nThe man folder contains all documentation files. However, you can imagine if we have two separate locations for our R code and our Rd help files, that at some point the code and documentation might get out of sync. For example, if we update the code, but forget to reflect changes in our manual, the usability of our package may be at stake and documentation to end-users might get confusing. Most of all, it would be a lot of work for us to maintain multiple linked files in multiple locations. roxygen2 solves this for us by extracting the documentation from our R code file. The only thing we need to do is maintain a single file: the code file in the R folder with some special code comments in roxygen style.\nA minimal example of roxygen code comments would be as follows, matching an R function with arguments x and y:\n#' A short description of your function\n#' \n#' @param x The expected input for the first function argument, x.\n#' @param y Input for the second argument denoted by the letter y.\n#' @returns A short description of the expected function output.\nTo start with roxygen2 in our package, we need to instruct the package to start using roxygen2:\n\nusethis::use_roxygen_md()\n\nThe above call will add the following two lines to our DESCRIPTION file, indicating that the package is documented using roxygen2.\nRoxygenNote: 7.3.3\nRoxygen: list(markdown = TRUE)\n\n\nWrite the function documentation\nIn RStudio, it is very easy to automatically insert the necessary roxygen code comments into to your function file. Place your cursor anywhere in the function code (click inside the round_to_integer() function definition in the round_to_integer.R file). Then click Code \\(\\rightarrow\\) Insert Roxygen Skeleton to automatically create the relevant roxygen documentation. The following code comments will appear:\n#' Title\n#'\n#' @param x \n#'\n#' @returns\n#' @export\n#'\n#' @examples\nFilling in the roxygen skeleton–with some customization and examples–could result in the following round_to_integer.R code file:\n\n#' Round to the nearest integer\n#'\n#' The \\code{\\link{base::round}} function rounds the number `1.5` to\n#' `2` and the number `2.5` also to `2`, because of the IEC 60559 standard.\n#' This function provides an integer rounding alternative to\n#' \\code{\\link{base::round}}.\n#'\n#' @param x A numeric element or vector to round to the nearest integer\n#' @returns An integer element or vector\n\n#' @author Gerko Vink \\email{g.vink@uu.nl} and Hanne Oberman\n#' \\email{h.i.oberman@uu.nl}\n#'\n#' #' @examples\n#' # unexpected rounding\n#' c(0.5, 1.5, 2.5, 3.5) |&gt; round()\n#' # rounding to nearest integer\n#' c(0.5, 1.5, 2.5, 3.5) |&gt; round_to_integer()\n#' \n#' @export\nround_to_integer &lt;- function(x){\n  # calculate difference between the value and the nearest integer below\n  diff &lt;- x - floor(x)\n  # for differences &lt; 0.5, return the nearest integer below\n  # for differences =&gt; 0.5, return the next nearest integer\n  ifelse(between(diff, 0.5, 1), ceiling(x), floor(x))\n}\n\nYou can copy the roxygen comments to your round_to_integer.R file. A good source to find inspiration for writing roxygen2 documentation is the roxygen2 reference page.\n\n\nGenerate the package documentation\nNow that we have a working round_to_integer.R file with documentation code included, we can build the documentation files. A good wrapper function to render all documentation in your package is the following code evaluation:\n\ndevtools::document()\n\nThe document() function from the devtools package will build all documentation for all files that use roxygen2 and it will build the NAMESPACE of your package accordingly.\n\n\n\n\n\n\nTip\n\n\n\nIf you encounter the following message:\nSkipping NAMESPACE\n✖ It already exists and was not generated by roxygen2. \njust remove the NAMESPACE file and re-run the document() function.\n\n\nBy now, your function should have a corresponding help file in the man folder, round_to_integer.Rd. We will remove the R/hello.R and man/hello.Rd files as they are not supposed to be part of our package.\nDelete the file hello.R from the R folder manually or with:\n\nfile.remove(\"./R/hello.R\")\n\nRe-render the package documentation to remove the function help file too:\n\ndevtools::document()",
    "crumbs": [
      "Part 1: Basics"
    ]
  },
  {
    "objectID": "01_basics.html#evaluating-the-r-package",
    "href": "01_basics.html#evaluating-the-r-package",
    "title": "The basics",
    "section": "Evaluating the R package",
    "text": "Evaluating the R package\nTo find out whether we’ve created a functioning R package, we can use the built-in checking tools in RStudio or the devtools function check(). The check() function executes an evaluation suite similar to the ones for CRAN. Whichever method you choose, they all result in an R CMD check, which is “the official method for checking that an R package is valid”.\n\nRun package check\nLet’s check the functionality of our package by clicking Check in the Build tab, or running:\n\ndevtools::check()\n\nWe can see that our current package yields 1 error, 1 warning and 1 note:\n1 error ✖ | 1 warning ✖ | 1 note ✖\n\n\nInvestigate the error\nThe error message is as follows:\n❯ checking examples ... ERROR\n  Running examples in ‘roundR-Ex.R’ failed\n  The error most likely occurred in:\n  \n  &gt; base::assign(\".ptime\", proc.time(), pos = \"CheckExEnv\")\n  &gt; ### Name: round_to_integer\n  &gt; ### Title: Round to the nearest integer\n  &gt; ### Aliases: round_to_integer\n  &gt; \n  &gt; ### ** Examples\n  &gt; \n  &gt; # unexpected rounding\n  &gt; c(0.5, 1.5, 2.5, 3.5) |&gt; round()\n  [1] 0 2 2 4\n  &gt; # rounding to nearest integer\n  &gt; c(0.5, 1.5, 2.5, 3.5) |&gt; round_to_integer()\n  Error in between(diff, 0, 0.5) : could not find function \"between\"\n  Calls: round_to_integer -&gt; ifelse\n  Execution halted\nThe error arises from the examples in our documentation. But the issue itself lies within the round_to_integer() function code. Inside the function, we use the between() function from the dplyr package. But we did not explicitly load that package before running the example.\nThe examples are self-contained, meaning that any dependent packages need to be explicitly loaded via library() for the code to run, just like any other R instance. Simply adding library(dplyr) to the example code will solve the error.\nNavigate to the round_to_integer.R file and add library(dplyr) to the examples. The examples now contain:\n\n#' @examples\n#' library(dplyr)\n#' # unexpected rounding\n#' c(0.5, 1.5, 2.5, 3.5) |&gt; round()\n#' # rounding to nearest integer\n#' c(0.5, 1.5, 2.5, 3.5) |&gt; round_to_integer()\n\n\n\nInvestigate the warning\nThe warning message is as follows:\n❯ checking Rd cross-references ... WARNING\n  Missing link(s) in Rd file 'round_to_integer.Rd':\n    ‘base::round’\n  \n  See section 'Cross-references' in the 'Writing R Extensions' manual.\n  \n  Found the following Rd file(s) with Rd \\link{} targets missing package\n  anchors:\n    round_to_integer.Rd: base::round\n  Please provide package anchors for all Rd \\link{} targets not in the\n  package itself and the base packages.\nThe error stems from the cross-reference we attempted in our documentation. The proper way to refer to function round() from package base is not with \\link{base::round}, but with [base::round()] following the structure [otherpkg::otherfunction()]. We could have opted for not referencing or linking the round() function at all, but this would not align with open and inclusive development conventions.\nCorrect the faulty cross-references in the documentation:\n\n#' The [base::round()] function rounds the number `1.5` to `2` and the number\n#' `2.5` also to `2`, because of the IEC 60559 standard. This function provides\n#' an integer rounding alternative to [base::round()].\n\n\n\nInvestigate the note\nThe note message is as follows:\n❯ checking R code for possible problems ... NOTE\n  round_to_integer: no visible global function definition for ‘between’\n  Undefined global functions or variables:\n    between\nWe use function between() from package dplyr, but we neglected to make explicit that the function between() is required for our function round_to_integer() to work. In other words, R needs to know that our package roundR would depend on package dplyr for its functionality to work.\nWe can fix this in two steps: 1) Tell R explicitly that we are using the between() function from the dplyr package in the definition of our function by adding dplyr:: to the function body:\n\nround_to_integer &lt;- function(x){\n  # calculate difference between the value and the nearest integer below\n  diff &lt;- x - floor(x)\n  # for differences &lt; 0.5, return the nearest integer below\n  # for differences =&gt; 0.5, return the next nearest integer\n  ifelse(dplyr::between(diff, 0.5, 1), ceiling(x), floor(x))\n}\n\nand 2) Add dplyr as a dependency to our package by importing the required between() function:\n\nusethis::use_import_from(\"dplyr\", \"between\")\n\n\n\n\n\n\n\nTip\n\n\n\nWhen asked:\n! `use_import_from()` requires package-level documentation.\n  Would you like to add it now?\n\n1: No way\n2: Not now\n3: For sure\n\nSelection: \nEnter an item from the menu, or 0 to exit\nchoose the fun option that would add it (i.e. For Sure, Yes, Absolutely, etc). These options change every time you re-run the function code, so read it carefully!\n\n\nIn the folder R, there should now be a new file roundR-package.R with some roxygen code, which means we have to re-run devtools::document() to update our documentation.\n\n\nRe-render documentation\nUpdate the package documentation with:\n\ndevtools::document()\n\nEvaluate what happened. What has changed in our DESCRIPTION and NAMESPACE files? If you want to learn more about R package dependencies, see the Dependencies and Imports section in the R Packages book.\n\n\nRe-run checks\nTry re-running the check() to see if you hit three green check marks (no more errors, warnings and notes):\n\ndevtools::check()\n\nIf all is well, you’ll see:\n── R CMD check results ───────────────────────────────── roundR 0.1.0 ────\nDuration: 5.7s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\nR CMD check succeeded\nThis means that, in principle, you could go ahead and submit this package to CRAN. But let’s first try and use our new package locally.\n\n\nTry the package\nDuring R package development, you will probably often try and see whether your code runs as expected–specifically whether your functions work as you’d hoped. Your new favorite function might be devtools::load_all().\nLoad the current development version of the package:\n\ndevtools::load_all()\n\nRun some code to try our function from the loaded package, for example:\n\nround_to_integer(2.5)\n\n\nInstead of running R code manually to verify whether our function performs as expected, we can automate this with tests.\n\n\nAdd tests\nThe next step for a mature package is to include tests. Every function should have functional tests. The testthat package is geared to that. Make sure that you have the round_to_integer.R file open in the Source pane and run:\n\nusethis::use_test()\n\nThe proper structure for test files has now been created:\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Setting Config/testthat/edition field in DESCRIPTION to '3'\n✔ Creating 'tests/testthat/'\n✔ Writing 'tests/testthat.R'\n✔ Writing 'tests/testthat/test-round_to_integer.R'\n• Modify 'tests/testthat/test-round_to_integer.R'\nYou are asked to modify the tests/testthat/test-round_to_integer.R file. Replace the example test with:\n\ntest_that(\"round_to_integer works\", {\n  A &lt;- c(0.5, 1.5, 2.5, 3.5) |&gt; round_to_integer()\n  B &lt;- c(0.49, 1.49, 2.49, 3.49) |&gt; round_to_integer()\n  expect_equal(A, c(1, 2, 3, 4))\n  expect_equal(B, c(0, 1, 2, 3))\n})\n\ntest_that(\"round_to_integer yields different results than round\", {\n  vec1 &lt;- c(0.5, 1.5, 2.5, 3.5)\n  vec2 &lt;- c(\n    0.499999999999999999995,\n    1.499999999999999999995,\n    2.499999999999999999995,\n    3.499999999999999999995\n  )\n  A &lt;- vec1 |&gt; round_to_integer()\n  B &lt;- vec1 |&gt; round()\n  C &lt;- vec2 |&gt; round_to_integer()\n  D &lt;- vec2 |&gt; round()\n  expect_false(identical(A, B))\n  expect_false(identical(C, D))\n})\n\nClick the Test button in the Build pane, or run:\n\ndevtools::test()\n\nAll test should pass, meaning that your round_to_integer() function yields correct results (test 1) that differ fundamentally from the results obtained with round() (test 2).\nIf test would fail, you’d be notified. For example\n\ntest_that(\"round_to_integer works\", {\n  A &lt;- c(0.5, 1.5, 2.5, 3.5) |&gt; round_to_integer()\n  expect_equal(A, c(4, 3, 2, 1))\n  })\n\n── Failure: round_to_integer works ─────────────────────────────────────────────\n`A` not equal to c(4, 3, 2, 1).\n4/4 mismatches (average diff: 2)\n[1] 1 - 4 == -3\n[2] 2 - 3 == -1\n[3] 3 - 2 ==  1\n[4] 4 - 1 ==  3\n\n\nError:\n! Test failed\n\n\nFortunately, our test all passed. Now re-run the R CMD check. If all is well you’ll receive confirmation of a successful check.\n\n\nIncrease the version\nNow that we have a working package with successful checks, we might think about updating the version of the package. After all, a lot has changed since the package got defined at the start of our development journey.\nThe easiest means to increasing the version to 0.1.0 (indicating a minor update) is to use\n\nusethis::use_version(which = \"minor\")\n\n\n\n\n\n\n\nTip\n\n\n\nYou will be presented with something like:\n✔ Adding \"0.1.0\" to Version.\nℹ There is 1 uncommitted file:\n• DESCRIPTION\n! Is it ok to commit it?\n\n1: Definitely\n2: Absolutely not\n3: Negative\n\nSelection: \nThe question Is it ok to commit it? is related to git. Please select the affirmative option (such as Definitely) to commit the version increase. For reasons of brevity and simplicity, we will leave a thorough discussion of incremental git commits for now and demonstrate to use of git and GitHub at the end of this walk through.\n\n\n\n\nInstall your new package\nInstall the package by clicking Install in the Build tab. In the console, the following should occur:\nRestarting R session...\n&gt; library(roundR)\nYour package is now ready to use locally, but not yet ready to share with the world… That’s what the next part is all about!",
    "crumbs": [
      "Part 1: Basics"
    ]
  },
  {
    "objectID": "01_basics.html#footnotes",
    "href": "01_basics.html#footnotes",
    "title": "The basics",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nQuote by usethis developer Jenny Bryan↩︎",
    "crumbs": [
      "Part 1: Basics"
    ]
  },
  {
    "objectID": "00_requirements.html",
    "href": "00_requirements.html",
    "title": "Requirements",
    "section": "",
    "text": "It is much easier to create, manage and co-develop an R package when you incorporate it into a distributed version control system like git. The extension to a software development hosting service like GitHub is then a natural one. Although there are other procedures and DevOps systems and hosting services that may lend itself for package development, we outline the workflow with git and GitHub. We also assume that you have RStudio available (installed or online).\n—  Copyright Hanne Oberman, 2025 - CC BY-NC-SA 4.0  Materials developed by Amices team - Methodology & Statistics - Utrecht University",
    "crumbs": [
      "Requirements"
    ]
  },
  {
    "objectID": "00_requirements.html#assumed-prior-knowledge",
    "href": "00_requirements.html#assumed-prior-knowledge",
    "title": "Requirements",
    "section": "Assumed prior knowledge",
    "text": "Assumed prior knowledge\n\n\n\n\n\n\nR and RStudio\n\n\n\n\n\nUsing RStudio  RStudio is an R user’s best friend. The IDE provides an enhanced interface for coding in R, with built-in support for markdown languages and R package development. If you’re not familiar with R or RStudio, or need a refresher, please follow the tutorial in our crash course before continuing.\n\n\n\n\n\n\n\n\n\ngit and GitHub\n\n\n\n\n\nUsing Git Git is a free and open source version control system for text files. It can handle extensive change logging for you, no matter the size of the project. Git is fast and efficient, but its effectiveness depends also on the frequency you instruct it to log your project’s changes.\nYou can see Git as a blank canvas that starts at a certain point in time. Every time you (or others) instruct Git to log any changes that have been made, Git adds the changes that are made to this canvas. We call the changes to the canvas commits. With every commit an extensive log is created that includes at least the following information:\n\nthe changes made\nwho made the changes\nmetadata\na small piece of text that describe the changes made\n\nThe difference between two commits - or the changes between them - are called diffs.\nIf you’d like to know much more about Git, this online book is a very good resource. If you’d like to practice with the command line interface use this webpage for a quick course. This book covers pretty much everything you need to marry Git and R.\nUsing GitHub GitHub is the social and user interface to Git that allows you to work in repositories. These repositories can be seen as project folders in which you publish your work, but you can also use them as test sites for development, testing, etcetera. There is a distinction between private repositories (only for you and those you grant access) and public repositories (visible for everyone).\nYour public repositories can be viewed and forked by everyone. Forking is when other people create a copy of your repository on their own account. This allows them to work on a repository without affecting the master. You can also do this yourself, but then the process is called branching instead of forking. If you create a copy of a repository that is offline, the process is called cloning.\nGitHub’s ability to branch, fork and clone is very useful as it allows other people and yourself to experiment on (the code in) a repository before any definitive changes are merged with the master. If you’re working in a forked repository, you can submit a pull request to the repository collaborators to accept (or reject) any suggested changes.",
    "crumbs": [
      "Requirements"
    ]
  },
  {
    "objectID": "00_requirements.html#system-requirements",
    "href": "00_requirements.html#system-requirements",
    "title": "Requirements",
    "section": "System requirements",
    "text": "System requirements\nInstallation of R and RStudio or login online on Posit Cloud.\n\n\n\n\n\n\nR and RStudio on your own laptop\n\n\n\n\n\n1. Check R version (you will need version 4.1 or higher)\n\nR.version$version.string\n\n[1] \"R version 4.5.0 (2025-04-11)\"\n\n\n2. Check installation of R packages\nYou will need the R packages devtools and dplyr. You can verify whether all packages are installed correctly by running:\n\nall(c(\"devtools\", \"dplyr\", \"roxygen2\", \"usethis\", \"testthat\") %in% rownames(installed.packages()))\n\n[1] TRUE\n\n\nIf not yet installed, run:\n\ninstall.packages(c(\"devtools\", \"dplyr\", \"roxygen2\", \"usethis\", \"testthat\"))\n\n\n\n\n\n\n\n\n\n\nR and RStudio online\n\n\n\n\n\n1. Go to https://posit.cloud/ and click on “Sign Up” in the top-right corner.\n\n2. Select “Cloud free” by clicking “Learn more” and sign up.\n\n3. Go to https://docs.posit.co/cloud/get_started/ and follow the instructions up to and including “Create a Project”\n4. Install the necessary R packages\n\ninstall.packages(c(\"devtools\", \"dplyr\"))\n\n\n\n\nInstalling git, and the benefits of GitHub for R package development.\n\n\n\n\n\n\nInstalling git on Mac\n\n\n\n\n\nI suggest you install Git by downloading and installing GitHub   Desktop. GitHub’s desktop application is a nice GUI and, naturally, integrates well into the repository workflow on GitHub.\nWhen installed, you can go to GitHub Desktop &gt; Install Command Line Tool\nAfter a reboot, all should be set.\n\n\n\n\n\n\n\n\n\nInstalling git on Windows\n\n\n\n\n\nDownload and install Git for Windows, Then download and install GitHub   Desktop. GitHub’s desktop application is a nice GUI and, naturally, integrates well into the repository workflow on GitHub.\nAfter a reboot, all should be set.\n\n\n\n\n\n\n\n\n\nUsing GitHub\n\n\n\n\n\nGitHub for R package development GitHub is the social and user interface to Git that allows you to work in repositories. These repositories can be seen as project folders in which you publish your work, but you can also use them as test sites for development, testing, etcetera. There is a distinction between private repositories (only for you and those you grant access) and public repositories (visible for everyone).\nYour public repositories can be viewed and forked by everyone. Forking is when other people create a copy of your repository on their own account. This allows them to work on a repository without affecting the master. You can also do this yourself, but then the process is called branching instead of forking. If you create a copy of a repository that is offline, the process is called cloning.\nGitHub’s ability to branch, fork and clone is very useful as it allows other people and yourself to experiment on (the code in) a repository before any definitive changes are merged with the master. If you’re working in a forked repository, you can submit a pull   request to the repository collaborators to accept (or reject) any suggested changes.\nFor now, this may be confusing, but I hope you recognize the benefits GitHub can have on the process of development and bug-fixing. For example, the most up-to-date version of the mice package in R can be directly installed from the mice repository with the following code devtools::install_github(repo = \"amices/mice\").\nYou can see that this process requires package devtools that expands the R functionality with essential development tools. Loading packages in R directly from their respective GitHub repositories, allows you to obtain the latest - often improved and less buggy - iteration of that software even before it is published on CRAN.\nOpening an account Go to GitHub and sign up. You may qualify for a free PRO subscription through GitHub’s education benefits.",
    "crumbs": [
      "Requirements"
    ]
  },
  {
    "objectID": "02_sharing.html",
    "href": "02_sharing.html",
    "title": "Sharing R packages",
    "section": "",
    "text": "Uploading to GitHub\n\n\n\n\n\n\nTip\n\n\n\nThis section assumes that you are logged into your GitHub account. If you have trouble realizing this, GitHub has a great step-by-step walk through.\n\n\nLet’s publish our R package to GitHub. To do so, we need to perform two steps. First, we must log (commit) our changes to the git distributed version control system. This stores the file changes to our own machine. Next we must link our local git to a remote online repository on GitHub. Luckily, with ‘GitHub Desktop’, we can perform all these steps in a single window interface.\nLet’s start by adding our R package to GitHub Desktop. Remember that we already started the package in RStudio as a git repository, so we only have to point GitHub Desktop to the correct directory.\n\n\n\nNext, we commit the changes. This means that we save the state of files for a moment in time, so that we can always revert to that state and see how the files changed with respect to the previous state.\n\n\n\nNaturally, you would not only do this at the start (when RStudio created the git repository) and end (when we have a working package), but at regular and informative intervals. For example, when you add a function, a test, a help file, a license, etcetera.\nNow that we have commited our package, we can publish it on GitHub.\n\n\n\nTry your online GitHub repositories at https://github.com. You will see your package there and that the license is automatically recognized. You will also see that you are in the main branch. By default, that will be the live version of your package. Now that your package is live, it would be nice to add a README file that informs visitors to your repository. But we will extend our workflow with a good behaviour: not working in the main branch. We would not want to accidentally overwrite or break the functionality of our package, just because we were working in the same branch. So let’s add a README to a new development branch.\n\n\n\nWhen we commit the new README file to the development branch, a new window opens to propose the pull request (PR). The PR is nothing more than a request to the package developers to pull your proposed changes into (usually) the main branch of the software. Since we are the developers, we have to both create and accept the PR.\n\n\n\nIt is good procedure to write an informative PR message, usually outlining the nature and rationale of the changes. I also demonstrate how to accept a PR, thereby approving the changes per file (only one now) and signing it with my initials. I cannot formally approve my own PR, since that would leave great opportunity for subjectivity or error. Proper procedure would be to have someone else check and approve your changes.\n\n\n\nWhen you go back to GitHub Desktop and fetch the changes on teh remote (that would be GitHub online), you will see that you have now access to the README file and the development branch.\n\n\nRegistering a DOI\nNow that we have a proper and open source package online and the world as our user base, it would be wise to allow for proper referencing of our package.\nGitHub and Zenodo have paired to facilitate this procedure. If you link your Zenodo account to GitHub, as outlined here, you only have to click, copy and paste to fully make your GitHub repo citeable.\n\n\n\n\n\nAdd citation\nZenodo prepares the repository citation for us. We can simply grab the info, change our personal information and submit it to GitHub.\n\n\n\nThe final step before we would put our package out there is to notify how users can refer to our package. Run the following code:\n\nusethis::use_citation()\n\nwhich will create the necessary citation files for modification\n\n✔ Creating 'inst/'\n✔ Writing 'inst/CITATION'\n• Modify 'inst/CITATION'\n\nWe can now simply grab the text and/or bibtex citation from GitHub and paste it into the CITATION file. The citation info cf. R packages could be:\n\ncitHeader(\"To cite roundR in publications use:\")\n\ncitEntry(\n  entry    = \"Manual\",\n  title    = \"hanneoberman/roundR: Version 0.1.0 - First release\",\n  author   = \"Gerko Vink and Hanne Oberman\",\n  year     = \"2025\",\n  doi      = \"10.5281/zenodo.7668889\",\n  url      = \"github.com/gerkovink/roundR\",\n  textVersion = paste(\n\"Vink, G and Oberman, H.I. (2025). gerkovink/roundR: Version 0.1.0 - First release (Version v0.2.0) [Computer software]. https://doi.org/10.5281/zenodo.7668889\"\n  )\n)\n\nModify this to your name and paste it into the CITATION file.\n\n\n\n\n\nInstalling your own package from GitHub\nGo to GitHub Desktop, and commit and push the changes to GitHub. Then run the following code block:\n\ndevtools::install_github(\"hanneoberman/roundR\")\n\nwhere you replace \"hanneoberman/roundR\" with your GitHub handle and repository name.\n\n\n\n\n\n\n\n—  Copyright Hanne Oberman, 2025 - CC BY-NC-SA 4.0  Materials developed by Amices team - Methodology & Statistics - Utrecht University",
    "crumbs": [
      "Part 2: Sharing"
    ]
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Develop an R package within an hour",
    "section": "",
    "text": "Tip\n\n\n\nThe complete 2023 version of this workshop is available on Zenodo.  The corresponding recording of this workshop is available here. Disclaimer: In the recording, there’s an error, caused by removing the GitHub repo roundR that was created in the exercise materials and re-creating it with the exact same roundR name during the lecture. That is why Zenodo does not accept it a second time for a DOI. This makes sense, as you would not want to create a new DOI for content with the same name at the same location, nor use the same DOI for content with different time codes and temporal origin. For your repository, however, this would not be an issue.\n—  Copyright Hanne Oberman, 2025 - CC BY-NC-SA 4.0  Materials developed by Amices team - Methodology & Statistics - Utrecht University"
  },
  {
    "objectID": "archive.html#steps-in-creating-an-r-package",
    "href": "archive.html#steps-in-creating-an-r-package",
    "title": "Develop an R package within an hour",
    "section": "3.1 Steps in creating an R-package",
    "text": "3.1 Steps in creating an R-package\n\n3.1.1 Packages and sources needed\nWe need the following packages to help us with building, testing and maintaining our package:\n\nlibrary(devtools) # development tools\nlibrary(usethis)  # automated package and project setup\nlibrary(testthat) # unit testing\n\n\n\n3.1.2 Preparing the package structure\nWe need a location for our R-package. The simplest approach to creating the skeleton for an R-package is to use RStudio. The following gif outlines this procedure:\n\n\n\nWe have now created the necessary structure for an R-package. We can see this structure and the generated package files in the File Pane in RStudio.\n\n\n\nThe R subfolder contains all the R-code for your package and the man folder contains all the corresponding R manuals. By default, for a new R-package generated by RStudio the file hello.R is generated.\n\n\n\nAs a matter of fact, the skeleton R-package is already a fully functional R-package. Try installing the package in the build pane.\n\n\n\n\n\n3.1.3 Add the description\nOpen the file DESCRIPTION from the file pane. The following window opens:\n\n\n\n\nNow, replace the contents of the DESCRIPTION file with\n\nPackage: roundR\nType: Package\nTitle: Round Numeric Values to the Nearest Integer\nVersion: 0.1.0\nAuthor: Gerko Vink and Hanne Oberman\nMaintainer: Gerko Vink &lt;G.Vink@uu.nl&gt;\nDescription: In R the default choice for rounding follows the IEC 60559 standard where a 5 is expected to be rounded to the even digit. This package offers alternative functionality to round to the closest integer. \nLicense: No LiCeNsE YeT\nEncoding: UTF-8\nLazyData: true\n\nThe DESCRIPTION file governs the information about the licence, authors, contributors, maintainers, etcetera. The argument lazyData: true indicates that data sets should be lazily loaded. This means that data will not occupy any memory unless it is needed. This is a good argument to have as default.\nWe also need to set a license. Running the following code from package usethis will write a permissive MIT license to the description file\n\nusethis::use_mit_license()\n\nDon’t forget to save the updated DESCRIPTION file and change our names to your name.\n\n\n3.1.4 Add the functional code\nNow it is time to extend the package with the functionality we promised in our updated DESCRIPTION. To do so, we start a new file names rounder.R by either manually creating it in the R sub folder, or by running the following code evaluation\n\nusethis::use_r(\"rounder\")\n\nThe use_r() function from the usethis package is very convenient, because it creates the necessary file in the correct location and opens the file in the editor pane.\n\n\n\n\nNow that we have created the file for our functional code, we can start building the code file. The most flexible approach to creating and maintaining a package is to use roxygen2. The roxygen2 package is a convenient in-line documentation convention that generates your Rd documentation, NAMESPACE file, and much more for you. Remember that man folder in our package root? That contains all documentation files. However, you can imagine if we have two separate locations for our R-code and our Rd help files, that at some point the code and documentation might get out of sync. For example, if we update the code, but forget to reflect changes in our manual, the usability of our package may be at stake and documentation to end-users might get confusing. Most of all, it would be a lot of work for us to maintain multiple linked files in multiple locations. roxygen2 solves this for us by extracting the documentation from our R-code file. The only thing we need to do is maintain a single file.\nTo start with roxygen2 in our package, we need to instruct the package to use roxygen2 from now on:\n\nusethis::use_roxygen_md()\n\nThe above call will add the following lines to our DESCRIPTION file:\n\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\nWe mentioned before that the roxygen2 engine expects the function documentation in the same file as the function code. A good starting point for that documentation is the following block:\n\n#' A short description of your function\n#' \n#' @param x The first argument to be governed by the letter x.\n#' @param y The second argument to denoted by the letter y.\n#' @returns a short description of the expected return.\n#' @examples\n#' examplecode 1\n#' examplecode 2\n\nIn R, when you have executed usethis::use_r() and have filled in your R code, you can run Code &gt; Insert Roxygen Skeleton to automatically create the relevant roxygen documentation. For our function rounder() - with some customization and examples, this could result in the following rounder.R code file\n\n#' Round to the nearest integer\n#'\n#'Function \\code{\\link{base::round}} rounds - by default -  the number `1.5` to\n#'integer `2` and the number `2.5` also to integer `2`. The reason for this\n#'behaviour is the IEC 60559 standard where a 5 is expected to be rounded to the\n#'even digit. This function provides an integer rounding alternative to\n#'\\code{\\link{base::round}}.\n#'\n#' @param x A numeric element or vector to round to the nearest integer\n#' @returns An integer element or vector\n#' @author Gerko Vink \\email{g.vink@uu.nl} and Hanne Oberman \\email{h.i.oberman@uu.nl}\n#' @examples\n#' # rounds weirdly\n#' c(0.5, 1.5, 2.5, 3.5) %&gt;% round()\n#' # rounds correctly\n#' c(0.5, 1.5, 2.5, 3.5) %&gt;% rounder()\n#'\nrounder &lt;- function(x) {\n  diff &lt;- x - floor(x)\n  out &lt;- x %&gt;% ceiling()\n  out[diff &lt; .5] &lt;- floor(x)[diff &lt; .5]\n  return(out)\n}\n\nYou can copy the above code chunk to your rounder.R file. A good source to find inspiration for writing roxygen2 documentation is the roxygen2 reference page.\nNow that we have a working rounder.R file with documentation included, we can build the documentation. A good wrapper function to build all documentation in your package is the following code evaluation:\n\ndevtools::document()\n\n\n\n\n\nThe document() function from the devtools package will build all documentation for all files that use roxygen2 and it will build the NAMESPACE of your package accordingly. If you encounter the following message:\n\nSkipping NAMESPACE\n✖ It already exists and was not generated by roxygen2. \n\njust remove the NAMESPACE file and re-run the document() function.\nWe can now remove the R/hello.R and man/hello.Rd files as they are not supposed to be part of our package\n\n\n3.1.5 Building and checking\nLet’s check the functionality of our package.\n\n\n\n\nWe can see under build &gt; check that our current package yields 1 error, 1 warning and 1 note.\n\n3.1.5.1 Error\n\n❯ checking examples ... ERROR\n  Running examples in ‘roundR-Ex.R’ failed\n  The error most likely occurred in:\n\n    ...\n  \n  &gt; c(0.5, 1.5, 2.5, 3.5) %&gt;% round()\n  Error in c(0.5, 1.5, 2.5, 3.5) %&gt;% round() : \n    could not find function \"%&gt;%\"\n  Execution halted\n\nThe error stems from the examples in our documentation. The examples use the binary function %&gt;% from package magrittr, but we did not load that package in the example. Remember that these examples are self-contained and that any dependent packages need to be explicitly loaded via library() for the code to run. Just like any other R instance. Simply adding library(magrittr) to the example code will solve the issue.\nAdd library(magrittr) to the example code:\n\n#' @examples\n#' library(magrittr)\n#' # rounds weirdly\n#' c(0.5, 1.5, 2.5, 3.5) %&gt;% round()\n#' # rounds correctly\n#' c(0.5, 1.5, 2.5, 3.5) %&gt;% rounder()\n\n\n\n3.1.5.2 Warning\n\n❯ checking Rd cross-references ... WARNING\n  Missing link or links in documentation object 'rounder.Rd':\n    ‘base::round’\n  \n  See section 'Cross-references' in the 'Writing R Extensions' manual.\n\nThe error stems from the crossreference we attempted in our documentation. The proper way to refer to function round() from package base is not with \\link{base::round}, but with \\link[base]{round} following the structure \\link[package]{function}. We could have opted for not referencing, or linking the round() function at all, but this would not align with open and inclusive development conventions.\nCorrect the faulty crossreferences in the documentation:\n\n#'Function \\code{\\link[base]{round}} rounds - by default -  the number `1.5` to\n#'integer `2` and the number `2.5` also to integer `2`. The reason for this\n#'behaviour is the IEC 60559 standard where a 5 is expected to be rounded to the\n#'even digit. This function provides an integer rounding alternative to\n#'\\code{\\link[base]{round}}.\n\n\n\n3.1.5.3 Note\n\n❯ checking R code for possible problems ... NOTE\n  rounder: no visible global function definition for ‘%&gt;%’\n  Undefined global functions or variables:\n    %&gt;%\n\nWe use function %&gt;% from package magrittr, but we neglected to make explicit that this function should have been imported from package magrittr. In other words, R needs to know that our package roundR would depend on package magrittr for its functionality to work.\nWe can fix this by running the following usethis evaluation in the console:\n\nusethis::use_import_from(\"magrittr\", \"%&gt;%\")\n\nWhen asked\n\n`use_import_from()` requires package-level documentation.\nWould you like to add it now?\n\n1: For sure\n2: Not now\n3: No way\n\nchoose the fun option that would add it (i.e. For Sure, Yes, Absolutely, etc). These options change every time you re-run the function code, so read it carefully!\nOnce you have selected the correct option, we can re-run the CHECK. You will find that there still persists an error in the example:\n\n❯ checking examples ... ERROR\n  Running examples in ‘roundR-Ex.R’ failed\n  The error most likely occurred in:\n  \n  ...\n  \n  &gt; c(0.5, 1.5, 2.5, 3.5) %&gt;% rounder()\n  Error in rounder(.) : could not find function \"rounder\"\n  Calls: %&gt;%\n  Execution halted\n\nOur package CHECK cannot find function rounder(). That may seem weird, since it is the only function in our package. The thing is - we have not explicitly told roxygen2 to export our function, i.e. to make our function available outside of the package namespace. Simply adding @export to the rounder.R file would solve this error:\n\n...\n#' @author Gerko Vink \\email{g.vink@uu.nl} and Hanne Oberman \\email{h.i.oberman@uu.nl}\n#' @export\n#' @examples\n#' library(magrittr)\n...\n\nTry re-running the CHECK to see if you hit three green check marks (NO errors, warnings and notes). If all is well, you’ll see:\n\n── R CMD check results ────────────────────────────────────────── roundR 0.1.0 ────\nDuration: 6.6s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n\nR CMD check succeeded\n\n\n\n\n3.1.6 Increasing the version\nNow that we have a working package with a successful R CMD check, we might think about updating the version of the package. After all, a lot has changed since the last version got defined at the start of our development journey.\nThe easiest means to increasing the version to 0.2.0 (indicating a minor update) is to use\n\nusethis::use_version()\n\nYou will be presented with something like:\n\n✔ Setting active project to '/Users/gerko/surfdrive/Werk/GitHub/roundR/roundR'\nCurrent version is 0.1.1.\nWhat should the new version be? (0 to exit) \n\n1: major --&gt; 1.0.0\n2: minor --&gt; 0.2.0\n3: patch --&gt; 0.1.2\n4:   dev --&gt; 0.1.1.9000\n\nSelection: 2\n✔ Setting Version field in DESCRIPTION to '0.2.0'\nThere is 1 uncommitted file:\n* 'DESCRIPTION'\nIs it ok to commit it?\n\n1: For sure\n2: Negative\n3: Nope\n\nSelection: 1\n✔ Adding files\n✔ Making a commit with message 'Increment version number to 0.2.0'\n\nThe question Is it ok to commit it? is related to Git. Please click to commit the version increase. For reasons of brevity and simplicity, we will leave a thorough discussion of incremental Git commits for now and demonstrate to use of Git and GitHub at the end of this walkthrough.\n\n\n3.1.7 Add tests\nThe next step for a mature package is to include tests. Every function should have functional tests. The testthat package is geared to that. Make sure that you have the rounder.R file open in the Source pane and run:\n\nusethis::use_test()\n\nThe proper structure for test files has now been created:\n\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Setting Config/testthat/edition field in DESCRIPTION to '3'\n✔ Creating 'tests/testthat/'\n✔ Writing 'tests/testthat.R'\n✔ Writing 'tests/testthat/test-rounder.R'\n• Modify 'tests/testthat/test-rounder.R'\n\nYou are asked to modify the tests/testthat/test-rounder.R file. Replace the example test with:\n\ntest_that(\"rounder works\", {\n  A &lt;- c(0.5, 1.5, 2.5, 3.5) %&gt;% rounder()\n  B &lt;- c(0.49, 1.49, 2.49, 3.49) %&gt;% rounder()\n  expect_equal(A, c(1, 2, 3, 4))\n  expect_equal(B, c(0, 1, 2, 3))\n})\n\ntest_that(\"rounder yields different results than round\", {\n  vec1 &lt;- c(0.5, 1.5, 2.5, 3.5)\n  vec2 &lt;- c(0.499999999999999999995,\n            1.499999999999999999995,\n            2.499999999999999999995,\n            3.499999999999999999995)\n  A &lt;- vec1 %&gt;% rounder()\n  B &lt;- vec1 %&gt;% round()\n  C &lt;- vec2 %&gt;% rounder()\n  D &lt;- vec2 %&gt;% round()\n  expect_false(identical(A, B))\n  expect_false(identical(C, D))\n})\n\nClick the Test button in the build pane:\n\n\n\nAll test should pass, meaning that your rounder() function yields correct results (test 1) that differ fundamentally from the results obtained with round() (test 2).\nIf test would fail, you’d be notified. For example\n\ntest_that(\"rounder works\", {\n  A &lt;- c(0.5, 1.5, 2.5, 3.5) %&gt;% rounder()\n  expect_equal(A, c(4, 3, 2, 1))\n  })\n\n── Failure: rounder works ──────────────────────────────────────────────────────\n`A` not equal to c(4, 3, 2, 1).\n4/4 mismatches (average diff: 2)\n[1] 1 - 4 == -3\n[2] 2 - 3 == -1\n[3] 3 - 2 ==  1\n[4] 4 - 1 ==  3\n\n\nError:\n! Test failed\n\n\nFortunately, our test all passed. Now rerun the R CMD check. If all is well you’ll receive confirmation of a successful check.\n\n\n3.1.8 Publishing to GitHub\nThis section assumes that you are logged into your GitHub account. If you have trouble realizing this, GitHub has a great step-by-step walkthrough.\nLet’s publish our R-package to GitHub. To do so, we need to perform two steps. First, we must log (commit) our changes to the Git distributed version control system. This stores the file changes to our own machine. Next we must link our local Git to a remote online repository on GitHub. Luckily, with GitHub Desktop, we can perform all these steps in a single window interface.\nLet’s start by adding our R-package to GitHub desktop. Remember that we already started the package in RStudio as a Git repository, so we only have to point GitHub desktop to the correct directory.\n\n\n\nNext, we commit the changes. This means that we save the state of files for a moment in time, so that we can always revert to that state and see how the files changed with respect to the previous state.\n\n\n\nNaturally, you would not only do this at the start (when RStudio created the Git repository) and end (when we have a working package), but at regular and informative intervals. For example, when you add a function, a test, a help file, a license, etcetera.\nNow that we have commited our package, we can publish it on GitHub.\n\n\n\nTry your online GitHub repositories at https://github.com. You will see your package there and that the license is automatically recognized. You will also see that you are in the main branch. By default, that will be the live version of your package. Now that your package is live, it would be nice to add a Readme file that informs visitors to your repository. But we will extend our workflow with a good behaviour: not working in the main branch. We would not want to accidentally overwrite or break the functionality of our package, just because we were working in the same branch. So let’s add a Readme to a new development branch.\n\n\n\nWhen we commit the new Readme file to the development branch, a new window opens to propose the pull request (PR). The PR is nothing more than a request to the package developers to pull your proposed changes into (usually) the main branch of the software. Since we are the developers, we have to both create and accept the PR.\n\n\n\nIt is good procedure to write an informative PR message, usually outlining the nature and rationale of the changes. I also demonstrate how to accept a PR, thereby approving the changes per file (only one now) and signing it with my initials. I cannot formally approve my own PR, since that would leave great opportunity for subjectivity or error. Proper procedure would be to have someone else check and approve your changes.\n\n\n\nWhen you go back to GitHub desktop and fetch the changes on teh remote (that would be GitHub online), you will see that you have now access to the readme file and the development branch.\n\n\n3.1.9 Registering a DOI\nNow that we have a proper and open source package online and the world as our user base, it would be wise to allow for proper referencing of our package.\nGitHub and Zenodo have paired to facilitate this procedure. If you link your Zenodo account to GitHub, as outlined here, you only have to click, copy and paste to fully make your GitHub repo citeable.\n\n\n\n\n\n3.1.10 Add citation\nZenodo prepares the repository citation for us. We can simply grab the info, change our personal information and submit it to GitHub.\n\n\n\nThe final step before we would put our package out there is to notify how users can refer to our package. Run the following code:\n\nusethis::use_citation()\n\nwhich will create the necessary citation files for modification\n\n✔ Creating 'inst/'\n✔ Writing 'inst/CITATION'\n• Modify 'inst/CITATION'\n\nWe can now simply grab the text and/or bibtex citation from GitHub and paste it into the CITATION file. The citation info cf. R-packages could be:\n\ncitHeader(\"To cite roundR in publications use:\")\n\ncitEntry(\n  entry    = \"Manual\",\n  title    = \"gerkovink/roundR: Version 0.2.0 - First release\",\n  author   = \"Gerko Vink and Hanne Oberman\",\n  year     = \"2023\",\n  doi      = \"10.5281/zenodo.7668889\",\n  url      = \"github.com/gerkovink/roundR\",\n  textVersion = paste(\n\"Vink, G and Oberman, H.I. (2023). gerkovink/roundR: Version 0.2.0 - First release (Version v0.2.0) [Computer software]. https://doi.org/10.5281/zenodo.7668889\"\n  )\n)\n\nModify this to your name and paste it into the CITATION file."
  }
]